---
title: "Multi-Trait Spatial Analysis of Replicated Latin Square Field Experiment"
author: "Analysis Pipeline"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    theme: united
    code_folding: hide
knit: (function(inputFile, encoding) {rmarkdown::render(inputFile, encoding = encoding, output_dir = "../../results")})
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, 
                      fig.width = 12, fig.height = 8)
```

## 1. Introduction

This report extends the spatial analysis framework to all measured phenotypes in the inv4m field experiment. We systematically analyze nine traits (DTA, DTS, LAE, PH, EN, SL, BL, BW, EBA) using a consistent analytical pipeline that:

1. Handles missing data appropriately for valid model comparisons
2. Compares spatial autocorrelation patterns across traits via scaled variograms
3. Evaluates six hierarchical model structures for each phenotype
4. Quantifies treatment effects using the optimal model for each trait

## 2. Setup and Data Preparation

### 2.1. Load Libraries

```{r load-libraries}
# Load the inv4mHighland package with all analysis functions
library(inv4mHighland)

# Additional libraries for visualization and reporting
library(tidyverse)
library(knitr)
library(ggpubr)
library(ggtext)
library(VIM)
```

### 2.2. Load and Clean Data

```{r load-data}
# Load the dataset
file_path <- "/Users/fvrodriguez/Desktop/inv4mHighland/data/CLY25_Inv4m.csv"
if (!file.exists(file_path)) {
  stop("Error: CLY25_Inv4m.csv not found in the working directory.")
} else {
  field_data_raw <- read.csv(file_path, na.strings = c("","#N/A","NA"))
  
  # Clean and prepare data
  field_data <- field_data_raw %>%
    # Calculate Estimated Blade Area (EBA) = 0.75 * BL * BW FIRST
    mutate(EBA = 0.75 * BL * BW) %>%
    rename(
      plant_id = plant,
      block = rep,
      x = X_pos,
      y = Y_pos,
      inv4m = inv4m_gt
    ) %>%
    # Convert relevant columns to factors
    mutate(across(c(plot_id, block, donor, inv4m), as.factor)) %>%
    # Add small amount of noise to x coordinates to avoid identical positions
    mutate(x = x + runif(n(), min = 0.0, max = 0.01))

  # Define phenotypes to analyze
  phenotypes <- c("DTA", "DTS", "LAE", "PH", "EN", "SL", "BL", "BW", "EBA")
  
  # Verify all phenotypes exist in the dataset
  available_phenotypes <- intersect(phenotypes, names(field_data))
  phenotypes <- available_phenotypes
  
  cat("Data loaded and cleaned successfully!\n")
  cat("Phenotypes available for analysis:", paste(phenotypes, collapse = ", "), "\n")
  cat("Data dimensions:", dim(field_data), "\n")
}

head(field_data)
```

## 3. Missing Data Assessment

Understanding missing data patterns is crucial for valid statistical inference.

### 3.1. Missing Data Summary

```{r missing-data-summary}
# Create missing data summary for all phenotypes
missing_summary <- field_data %>%
  select(all_of(phenotypes)) %>%
  summarise(across(everything(), ~sum(is.na(.)))) %>%
  pivot_longer(everything(), names_to = "phenotype", values_to = "missing_count") %>%
  mutate(
    total_obs = nrow(field_data),
    missing_pct = round(missing_count / total_obs * 100, 1),
    available_n = total_obs - missing_count
  )

cat("Missing data patterns across all phenotypes:\n")
print(missing_summary)
```

### 3.2. Missing Data Patterns

```{r missing-patterns, fig.cap="Missing data patterns across all phenotypes including EBA"}
# Visualize missing data patterns using VIM
field_data %>%
  select(all_of(phenotypes)) %>%
  VIM::aggr(col = c('navyblue', 'red'), 
            numbers = TRUE, 
            sortVars = TRUE, 
            labels = phenotypes)
```

### 3.3. Check for Systematic Missing Data

```{r systematic-missing}
# Check if missing data is related to treatments
missing_by_treatment <- field_data %>%
  select(donor, inv4m, all_of(phenotypes)) %>%
  group_by(donor, inv4m) %>%
  summarise(across(all_of(phenotypes), ~sum(is.na(.))), .groups = 'drop')

cat("Missing data counts by treatment combination:\n")
print(missing_by_treatment)

# Check spatial distribution of missing data
if (all(c("x", "y") %in% names(field_data))) {
  field_data %>%
    select(x, y, all_of(phenotypes)) %>%
    mutate(any_missing = rowSums(is.na(select(., all_of(phenotypes)))) > 0) %>%
    ggplot(aes(x = x, y = y, color = any_missing)) +
    geom_point(alpha = 0.7) +
    scale_color_manual(values = c("FALSE" = "blue", "TRUE" = "red")) +
    labs(title = "Spatial distribution of missing observations",
         color = "Has missing\ndata") +
    theme_classic() +
    coord_equal()
} else {
  cat("No spatial coordinates available for spatial missing data plot\n")
}
```

## 4. Scaled Variogram Analysis

Comparing spatial autocorrelation patterns across phenotypes using standardized variograms.

### 4.1. Calculate Scaled Variograms

```{r calculate-variograms}
# Calculate scaled variograms for all phenotypes using enhanced package function
# This function now handles multiple traits internally and returns results for all successful calculations
variogram_results <- calculate_scaled_variogram(field_data, phenotypes)

# Create summary table with error handling
if (length(variogram_results) > 0) {
  vgm_summary <- map_dfr(variogram_results, function(x) {
    tryCatch({
      tibble(
        phenotype = if("phenotype" %in% names(x)) x$phenotype else "unknown",
        n_obs = if("n_obs" %in% names(x)) x$n_obs else NA,
        max_semivariance = if("max_gamma" %in% names(x) && is.numeric(x$max_gamma)) round(x$max_gamma, 3) else NA
      )
    }, error = function(e) {
      cat("Error processing variogram result:", e$message, "\n")
      tibble(phenotype = "error", n_obs = NA, max_semivariance = NA)
    })
  })
  
  cat("\n=== VARIOGRAM SUMMARY STATISTICS ===\n")
  print(vgm_summary)
} else {
  cat("No variograms could be calculated\n")
}
```

### 4.2. Plot Scaled Variograms

```{r plot-variograms, fig.cap="Scaled empirical variograms for all phenotypes (0-100 scale)"}
# Plot variograms if available
if (length(variogram_results) > 0) {
  # Combine all variogram data
  all_vgm_data <- map_dfr(variogram_results, function(x) {
    x$variogram %>%
      mutate(phenotype = x$phenotype,
             n_obs = x$n_obs)
  })

  # Create single combined variogram plot for direct comparison
  ggplot(all_vgm_data, aes(x = dist, y = gamma_scaled, color = phenotype)) +
    geom_point(alpha = 0.7, size = 1.5) +
    geom_line(alpha = 0.8, linewidth = 0.8) +
    scale_color_brewer(type = "qual", palette = "Set3") +
    labs(
      title = "Scaled Empirical Variograms - All Phenotypes",
      subtitle = "Scaled to 0-100 for direct comparison of spatial autocorrelation patterns",
      x = "Distance",
      y = "Scaled Semivariance (0-100)",
      color = "Phenotype"
    ) +
    theme_classic2(base_size = 12) +
    theme(
      legend.position = "right",
      legend.title = element_text(face = "bold"),
      plot.title = element_text(face = "bold")
    ) +
    guides(color = guide_legend(override.aes = list(alpha = 1, size = 2)))
} else {
  cat("No variogram data available for plotting\n")
}
```

## 5. Spatial Distribution Visualization

### 5.1. Create Spatial Distribution Plots

```{r spatial-plots, fig.cap="Spatial distribution of phenotypes across the experimental field"}
# Create spatial plots for all traits using the enhanced package function
# This function handles trait validation, plotting, and grouping automatically

# Define trait labels for better plot titles
trait_labels <- c(
  "Days to Anthesis" = "DTA",
  "Days to Silking" = "DTS", 
  "Leaves Above Ear" = "LAE",
  "Plant Height" = "PH",
  "Ear Number" = "EN",
  "Sheath Length" = "SL",
  "Blade Length" = "BL", 
  "Blade Width" = "BW",
  "Estimated Blade Area" = "EBA"
)

# Filter to available phenotypes and create spatial plots
available_trait_labels <- trait_labels[trait_labels %in% phenotypes]
show_spatial_distribution(field_data, available_trait_labels)
```

## 6. Comprehensive Model Comparison

### 6.1. Fit Spatial Models for All Phenotypes

```{r fit-all-models}
# Initialize results storage
all_models <- list()
all_model_stats <- data.frame()

# Fit models for each phenotype using package function
cat("=== FITTING SPATIAL MODELS FOR ALL PHENOTYPES ===\n")
for (trait in phenotypes) {
  cat("\n--- Processing", trait, "---\n")
  
  # Create complete-case dataset
  trait_data <- field_data %>%
    filter(!is.na(.data[[trait]]) & 
           !is.na(x) & !is.na(y) & 
           !is.na(donor) & !is.na(inv4m) & 
           !is.na(block) & !is.na(plot_id))
  
  # Add plot_row and plot_col if missing (for example data)
  if (!"plot_row" %in% names(trait_data)) {
    trait_data$plot_row <- trait_data$y
  }
  if (!"plot_col" %in% names(trait_data)) {
    trait_data$plot_col <- trait_data$x
  }
  
  cat("Sample size:", nrow(trait_data), "\n")
  
  if (nrow(trait_data) > 20) {  # Minimum sample size for model fitting
    tryCatch({
      # Fit all models using package function
      cat("Fitting spatial models...\n")
      trait_models <- fit_all_models(trait_data, trait)
      all_models[[trait]] <- trait_models
      
      # Extract statistics using package function
      trait_stats <- extract_model_stats(trait_models, trait)
      all_model_stats <- bind_rows(all_model_stats, trait_stats)
      
      # Count successful models
      successful_models <- names(trait_models)[!sapply(trait_models, is.null)]
      cat("Successful models:", length(successful_models), "out of 6\n")
      
    }, error = function(e) {
      cat("ERROR processing", trait, ":", e$message, "\n")
    })
  } else {
    cat("Warning: Insufficient data for", trait, "\n")
  }
}

cat("\n=== FINAL MODEL FITTING SUMMARY ===\n")
cat("Processed", length(all_models), "phenotypes\n")
if (nrow(all_model_stats) > 0) {
  cat("Generated", nrow(all_model_stats), "model statistics\n")
} else {
  cat("No model statistics generated\n")
}
```

### 6.2. Model Comparison Results

```{r model-comparison-results}
# Display model comparison results
if (nrow(all_model_stats) > 0) {
  cat("=== MODEL FITTING SUCCESS RATES ===\n")
  
  # Model-specific success rates
  model_success <- all_model_stats %>%
    group_by(model) %>%
    summarise(
      n_attempted = n(),
      n_successful = sum(!is.na(BIC)),
      n_failed = sum(is.na(BIC)),
      success_rate = round(n_successful / n_attempted * 100, 1),
      .groups = 'drop'
    )
  
  print(model_success)
  
  # Best model for each phenotype (excluding model_1)
  best_models <- all_model_stats %>%
    filter(!is.na(BIC) & model != "model_1") %>%
    group_by(phenotype) %>%
    slice_min(BIC, n = 1) %>%
    select(phenotype, best_model = model, best_BIC = BIC)
  
  if (nrow(best_models) > 0) {
    cat("\n=== BEST MODEL (LOWEST BIC) FOR EACH PHENOTYPE ===\n")
    print(best_models)
    
    # Model selection frequency
    model_frequency <- best_models %>%
      count(best_model, sort = TRUE) %>%
      mutate(frequency = round(n / nrow(best_models) * 100, 1))
    
    cat("\n=== FREQUENCY OF EACH MODEL BEING SELECTED AS BEST ===\n")
    print(model_frequency)
  } else {
    cat("No best model information available\n")
  }
} else {
  cat("No model statistics available\n")
}
```

### 6.3. Model Selection Visualization

```{r model-selection-viz, fig.cap="Model selection patterns across phenotypes"}
# Create model selection visualization
if (nrow(all_model_stats) > 0) {
  # BIC differences from best model
  bic_diff <- all_model_stats %>%
    filter(!is.na(BIC) & model != "model_1") %>%
    group_by(phenotype) %>%
    mutate(bic_diff = BIC - min(BIC, na.rm = TRUE)) %>%
    ungroup()
  
  if (nrow(bic_diff) > 0) {
    ggplot(bic_diff, aes(x = phenotype, y = bic_diff, fill = model)) +
      geom_col(position = "dodge") +
      scale_fill_brewer(type = "qual", palette = "Set3") +
      labs(
        title = "BIC differences from best model",
        subtitle = "Lower values indicate better fit",
        x = "Phenotype",
        y = "Î”BIC from best model",
        fill = "Model"
      ) +
      theme_classic() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))
  } else {
    cat("No BIC difference data available for visualization\n")
  }
} else {
  cat("No model selection visualization possible\n")
}
```

## 7. Treatment Effects Analysis

### 7.1. Extract Treatment Effects

```{r extract-treatment-effects}
# Extract treatment effects using best models and package functions
treatment_effects <- list()

if (exists("best_models") && nrow(best_models) > 0) {
  cat("=== EXTRACTING TREATMENT EFFECTS ===\n")
  
  for (trait in best_models$phenotype) {
    cat("Processing treatment effects for", trait, "...\n")
    
    best_model_info <- best_models %>% filter(phenotype == trait)
    if (nrow(best_model_info) > 0) {
      best_model_name <- best_model_info$best_model
      
      # Extract effects using package function
      effects <- extract_treatment_effects_emmeans(
        all_models[[trait]], 
        best_model_name, 
        trait
      )
      
      if (!is.null(effects)) {
        treatment_effects[[trait]] <- effects
        cat("  Successfully extracted effects\n")
      } else {
        cat("  Failed to extract effects\n")
      }
    }
  }
  
  cat("Treatment effects extracted for", length(treatment_effects), "traits\n")
} else {
  cat("No best models available for treatment effects extraction\n")
}
```

### 7.2. Treatment Effects Summary

```{r treatment-effects-summary}
# Display treatment effects results
if (length(treatment_effects) > 0) {
  # Summary of significant contrasts
  significant_effects <- map_dfr(treatment_effects, function(x) {
    if (!is.null(x$contrast_summary)) {
      x$contrast_summary %>%
        as_tibble() %>%
        mutate(phenotype = x$phenotype,
               model_used = x$model_used) %>%
        filter(p.value < 0.05) %>%
        select(phenotype, model_used, donor, estimate, SE, p.value)
    }
  })
  
  if (nrow(significant_effects) > 0) {
    cat("=== SIGNIFICANT INV4M EFFECTS (P < 0.05) BY DONOR BACKGROUND ===\n")
    print(significant_effects)
  } else {
    cat("No significant inv4m effects detected at p < 0.05\n")
  }
} else {
  cat("No treatment effects analysis results available\n")
}
```

### 7.3. Treatment Effects Forest Plot

```{r treatment-effects-viz, fig.cap="Forest plot of standardized inv4m effects"}
# Create forest plot if treatment effects are available
if (length(treatment_effects) > 0) {
  # Extract contrasts for forest plot
  forest_data <- map_dfr(treatment_effects, function(x) {
    if (!is.null(x$contrast_summary)) {
      x$contrast_summary %>%
        as_tibble() %>%
        mutate(
          phenotype = x$phenotype,
          model_used = x$model_used,
          std_effect = estimate / SE,
          ci_lower = (estimate - 1.96 * SE) / SE,
          ci_upper = (estimate + 1.96 * SE) / SE
        ) %>%
        select(phenotype, donor, std_effect, ci_lower, ci_upper, p.value)
    }
  })
  
  if (nrow(forest_data) > 0) {
    # Filter to significant effects and add Bonferroni correction
    forest_data <- forest_data %>%
      filter(p.value < 0.05) %>%
      mutate(
        p.adj = p.adjust(p.value, method = "bonferroni"),
        bonferroni_sig = p.adj < 0.05,
        trait_label = case_when(
          phenotype == "DTA" ~ "Days to Anthesis",
          phenotype == "DTS" ~ "Days to Silking", 
          phenotype == "LAE" ~ "Leaves Above Ear",
          phenotype == "PH" ~ "Plant Height",
          phenotype == "EN" ~ "Nodes with Ears",
          phenotype == "SL" ~ "Sheath Length",
          phenotype == "BL" ~ "Blade Length",
          phenotype == "BW" ~ "Blade Width",
          phenotype == "EBA" ~ "Estimated Blade Area",
          TRUE ~ phenotype
        ),
        predictor = paste0("Inv4m from ", donor)
      ) %>%
      arrange(desc(abs(std_effect))) %>%
      mutate(trait_label = factor(trait_label, levels = unique(trait_label)))
    
    if (nrow(forest_data) > 0) {
      # Create forest plot
      forest_plot <- forest_data %>%
        ggplot(aes(x = std_effect, y = trait_label)) +
        geom_vline(xintercept = 0, lty = 2) +
        geom_point(aes(color = bonferroni_sig), size = 3) +
        geom_errorbar(aes(xmin = ci_lower, xmax = ci_upper), width = 0.2) +
        facet_wrap(~ predictor, ncol = 2) +
        scale_color_manual(
          values = c("TRUE" = "red", "FALSE" = "black"),
          labels = c("TRUE" = "Bonferroni significant", "FALSE" = "Nominally significant"),
          name = "Significance"
        ) +
        labs(
          x = "Standardized Effect Size",
          y = "Trait",
          title = "Forest plot of Inv4m effects by donor background",
          caption = "All nominally significant effects shown (p < 0.05)."
        ) +
        theme_classic() +
        theme(
          axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "bottom"
        )
      
      print(forest_plot)
    } else {
      cat("No significant effects for forest plot\n")
    }
  } else {
    cat("No forest plot data available\n")
  }
} else {
  cat("No treatment effects available for forest plot\n")
}
```

## 8. Summary and Conclusions

### 8.1. Key Findings

```{r summary}
cat("=== ANALYSIS SUMMARY ===\n\n")

cat("1. MISSING DATA:\n")
if (exists("missing_summary") && !is.null(missing_summary)) {
  print(missing_summary)
} else {
  cat("Missing data summary not available\n")
}

cat("\n2. MODEL SELECTION:\n")
if (exists("best_models") && !is.null(best_models) && nrow(best_models) > 0) {
  model_frequency <- best_models %>%
    count(best_model, sort = TRUE) %>%
    mutate(frequency = round(n / nrow(best_models) * 100, 1))
  print(model_frequency)
} else {
  cat("No model selection results available\n")
}

cat("\n3. SIGNIFICANT TREATMENT EFFECTS:\n")
if (length(treatment_effects) > 0) {
  # Count significant effects
  n_significant <- sum(map_lgl(treatment_effects, function(x) {
    if (!is.null(x$contrast_summary)) {
      any(x$contrast_summary$p.value < 0.05)
    } else {
      FALSE
    }
  }))
  cat("Found significant effects in", n_significant, "out of", length(treatment_effects), "phenotypes\n")
} else {
  cat("No treatment effects analysis completed\n")
}

cat("\n4. SPATIAL AUTOCORRELATION:\n")
if (length(variogram_results) > 0) {
  cat("Variograms calculated for", length(variogram_results), "phenotypes\n")
  cat("All phenotypes showed evidence of spatial structure in their variograms\n")
} else {
  cat("No variograms could be calculated\n")
}
```

### 8.2. Methodological Notes

This analysis demonstrates the step-by-step application of the **inv4mHighland** package functions:

1. **Data preparation**: Standard data cleaning and phenotype definition
2. **Missing data assessment**: Systematic evaluation of data completeness patterns
3. **Spatial autocorrelation analysis**: Using `calculate_scaled_variogram()` for each trait
4. **Spatial visualization**: Using `create_spatial_plot()` for field distribution maps
5. **Model comparison**: Using `fit_all_models()` and `extract_model_stats()` for systematic model selection
6. **Treatment effects**: Using `extract_treatment_effects_emmeans()` for statistical inference

Each step builds upon the previous ones, demonstrating the complete spatial analysis workflow implemented in the package functions.

### 8.3. Recommendations

1. **Model selection**: Use the phenotype-specific best models identified in this analysis for final inference

2. **Multiple testing**: Consider adjusting p-values for multiple phenotype comparisons when making biological conclusions

3. **Biological interpretation**: Interpret spatial patterns and treatment effects within the context of plant biology and field experimental design

4. **Package utilization**: The **inv4mHighland** functions provide a consistent and reproducible framework for spatial analysis across different experiments and datasets

This notebook demonstrates how the modular package functions can be combined to create a complete spatial analysis workflow while maintaining transparency about each analytical step.